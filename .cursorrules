---
description: "Cursor Rules for Ruby and Ruby on Rails Development"
alwaysApply: false
---
# Top 30 Cursor Rules for Ruby and Ruby on Rails Development

## Code Quality and Style

### 1. Enforce Ruby Style Guide Compliance
```ruby
# Always follow Ruby style guide conventions
class UserController < ApplicationController
  def index
    @users = User.all
  end
end
```
**Why**: Consistent code style improves readability and maintainability. Ruby has well-established conventions that should be followed across the team.

### 2. Prefer Symbol Keys Over String Keys
```ruby
# Good
user = { name: "John", email: "john@example.com" }

# Avoid
user = { "name" => "John", "email" => "john@example.com" }
```
**Why**: Symbol keys are more memory efficient and are the Ruby convention. They're also faster for hash lookups.

### 3. Use Guard Clauses for Early Returns
```ruby
# Good
def process_user(user)
  return unless user.valid?
  return unless user.active?
  
  # main logic here
end

# Avoid deep nesting
def process_user(user)
  if user.valid?
    if user.active?
      # main logic here
    end
  end
end
```
**Why**: Guard clauses reduce nesting and improve code readability, making the happy path more obvious.

### 4. Prefer `unless` for Negative Conditions
```ruby
# Good
return unless user.active?

# Avoid
return if !user.active?
```
**Why**: `unless` is more readable for negative conditions and is a Ruby idiom.

### 5. Use `&:` for Simple Method Calls
```ruby
# Good
names = users.map(&:name)
active_users = users.select(&:active?)

# Avoid
names = users.map { |user| user.name }
```
**Why**: More concise and readable for simple method calls.

## Rails-Specific Rules

### 6. Follow Rails Conventions Religiously
```ruby
# Controller naming
class UsersController < ApplicationController
  # Action naming follows REST conventions
  def index; end
  def show; end
  def create; end
  def update; end
  def destroy; end
end
```
**Why**: Rails conventions reduce cognitive load and make code predictable. Following conventions means less documentation needed.

### 7. Use Strong Parameters
```ruby
# Always use strong parameters
def user_params
  params.require(:user).permit(:name, :email, :role)
end
```
**Why**: Security best practice that prevents mass assignment vulnerabilities.

### 8. Prefer `find_by` Over `where().first`
```ruby
# Good
user = User.find_by(email: email)

# Avoid
user = User.where(email: email).first
```
**Why**: More readable and slightly more efficient.

### 9. Use `presence` for Conditional Assignments
```ruby
# Good
name = params[:name].presence || "Anonymous"

# Avoid
name = params[:name].blank? ? "Anonymous" : params[:name]
```
**Why**: More concise and readable for conditional assignments.

### 10. Prefer `try` Over Conditional Checks
```ruby
# Good
user_name = user.try(:name)

# Avoid
user_name = user.name if user
```
**Why**: More concise and handles nil cases gracefully.

## Performance and Efficiency

### 11. Use `includes` for N+1 Queries
```ruby
# Good
@users = User.includes(:posts, :comments)

# Avoid
@users = User.all # This will cause N+1 queries
```
**Why**: Critical for performance. N+1 queries are a common Rails performance issue.

### 12. Use `pluck` for Large Collections
```ruby
# Good
user_ids = User.active.pluck(:id)

# Avoid
user_ids = User.active.map(&:id)
```
**Why**: `pluck` is much more efficient as it only selects the specified columns from the database.

### 13. Use `exists?` for Existence Checks
```ruby
# Good
if User.exists?(email: email)
  # do something
end

# Avoid
if User.where(email: email).any?
  # do something
end
```
**Why**: `exists?` is optimized for existence checks and doesn't load records into memory.

### 14. Use `find_each` for Large Iterations
```ruby
# Good
User.find_each(batch_size: 1000) do |user|
  process_user(user)
end

# Avoid
User.all.each do |user|
  process_user(user)
end
```
**Why**: Prevents memory issues when processing large datasets.

### 15. Use `update_all` for Bulk Updates
```ruby
# Good
User.active.update_all(last_login_at: Time.current)

# Avoid
User.active.each { |user| user.update(last_login_at: Time.current) }
```
**Why**: Much more efficient for bulk operations.

## Testing Rules

### 16. Use Descriptive Test Names
```ruby
# Good
test "should create user with valid attributes" do
  # test code
end

# Avoid
test "test user creation" do
  # test code
end
```
**Why**: Descriptive test names serve as documentation and make failures easier to debug.

### 17. Use Factory Methods for Test Data
```ruby
# Good
user = create(:user, :admin)

# Avoid
user = User.create(name: "Test User", email: "test@example.com", role: "admin")
```
**Why**: More maintainable and reusable test data setup.

### 18. Test Edge Cases and Error Conditions
```ruby
# Always test both success and failure cases
test "should not create user with invalid email" do
  user = User.new(email: "invalid-email")
  assert_not user.valid?
end
```
**Why**: Ensures robust error handling and prevents bugs in production.

### 19. Use Shared Examples for Common Behavior
```ruby
# Good
RSpec.shared_examples "authenticatable" do
  it "requires authentication" do
    # test code
  end
end
```
**Why**: Reduces code duplication and ensures consistent behavior across similar components.

### 20. Mock External Services
```ruby
# Good
before do
  stub_request(:post, "https://api.example.com/webhook")
    .to_return(status: 200, body: "")
end
```
**Why**: Makes tests faster and more reliable by not depending on external services.

## Security Rules

### 21. Always Validate User Input
```ruby
# Good
class User < ApplicationRecord
  validates :email, presence: true, format: { with: URI::MailTo::EMAIL_REGEXP }
  validates :role, inclusion: { in: %w[user admin] }
end
```
**Why**: Prevents security vulnerabilities and data corruption.

### 22. Use `current_user` Helper
```ruby
# Good
def show
  @user = current_user
end

# Avoid
def show
  @user = User.find(session[:user_id])
end
```
**Why**: Centralizes authentication logic and makes it easier to change authentication systems.

### 23. Use `before_action` for Authorization
```ruby
# Good
class AdminController < ApplicationController
  before_action :require_admin
  
  private
  
  def require_admin
    redirect_to root_path unless current_user&.admin?
  end
end
```
**Why**: Ensures authorization is checked before any action is executed.

### 24. Use `secure_compare` for Sensitive Comparisons
```ruby
# Good
if ActiveSupport::SecurityUtils.secure_compare(token, expected_token)
  # proceed
end

# Avoid
if token == expected_token
  # proceed
end
```
**Why**: Prevents timing attacks on sensitive data comparisons.

### 25. Use `Rails.application.secrets` for Sensitive Data
```ruby
# Good
api_key = Rails.application.secrets.api_key

# Avoid
api_key = "hardcoded_key_here"
```
**Why**: Keeps sensitive data out of version control and allows different values per environment.

## Code Organization

### 26. Use Service Objects for Complex Logic
```ruby
# Good
class UserRegistrationService
  def initialize(user_params)
    @user_params = user_params
  end
  
  def call
    # complex registration logic
  end
end
```
**Why**: Keeps controllers thin and makes complex business logic testable and reusable.

### 27. Use Concerns for Shared Behavior
```ruby
# Good
module Searchable
  extend ActiveSupport::Concern
  
  included do
    scope :search, ->(query) { where("name ILIKE ?", "%#{query}%") }
  end
end
```
**Why**: Promotes code reuse and keeps models focused on their primary responsibilities.

### 28. Use `delegate` for Common Associations
```ruby
# Good
class Post < ApplicationRecord
  belongs_to :user
  delegate :name, to: :user, prefix: true
end

# Usage
post.user_name # instead of post.user.name
```
**Why**: Reduces coupling and makes code more readable.

### 29. Use `private` and `protected` Methods
```ruby
# Good
class UserController < ApplicationController
  def create
    @user = User.new(user_params)
    if @user.save
      redirect_to @user
    else
      render :new
    end
  end
  
  private
  
  def user_params
    params.require(:user).permit(:name, :email)
  end
end
```
**Why**: Clearly separates public interface from implementation details.

### 30. Use Meaningful Variable and Method Names
```ruby
# Good
def calculate_total_price_with_tax
  base_price + tax_amount
end

# Avoid
def calc
  bp + tax
end
```
**Why**: Self-documenting code reduces the need for comments and makes maintenance easier.

## Summary

These 30 rules represent the collective wisdom of experienced Ruby developers who use AI tools daily. They focus on:

1. **Code Quality**: Following Ruby conventions and writing readable, maintainable code
2. **Rails Best Practices**: Leveraging Rails conventions and avoiding common pitfalls
3. **Performance**: Writing efficient code that scales
4. **Testing**: Ensuring code quality through comprehensive testing
5. **Security**: Protecting applications from common vulnerabilities
6. **Organization**: Structuring code for maintainability and reusability

Each rule has been battle-tested in production environments and represents a consensus among the team about what makes Ruby and Rails code excellent when working with AI tools like Cursor.

